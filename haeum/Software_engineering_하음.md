1. 소프트웨어 공학이란
- 소프트웨어를 운영, 유지보수 폐기하는 데에 있어 최소 비용으로 최대 품질을 만들기 위한 학문
2. 소프트웨어 공학이 다루는 문제
- Software crisis를 극복하기 위해 필요하다. 비용, 시간, 안정성, 개발 이후에 생기는 어려움을 다룬다.
3. 소프트웨어 공학의 문제 접근방법
- 인력과 기술, 프로세스 세 관점에서 문제에 접근한다. 좋은 프로세스와 기술이 사용되고 인력이 훈련되어 있어야 좋은 품질의 소프트웨어를 기간 내에 공급할 수 있다.
4. 일정을 세우기 위한 방
- WBS : 할 일을 작은 요소로 계층화 하기
- CPM : 앞에서 작은 단위로 나눈 단계들의 의존 관계 순서 분석
- Gantt Chart : 앞선 분석 결과로 차트를 그린다.
5. 프로젝트 팀 구성원들은 어떻게 이루어지는가
- 프로젝트의 일정, 업무, 의사소통을 담당하는 프로젝트 매니저(PM)와 기술을 책임지는 프로젝트 리더(PL)
- 상세 설계를 맡는 엔지니어와 테스트를 계획하고 실시하는 테스터(QA)
- build하고 출시하는 팀과 문서 작업을 담당하는 Technical writer로 구성된다.
6. 프로젝트 과정 중 리스크가 일어날 수 있는 주요 요인은 어떤게 있는가?
-Estimition : 짧은 개발 일정, 저조한 오류 수정율, 잘못된 규모 추정
- Organization : 예산 축소, 프로젝트 관리 담당 부서 변경
- People : 기술 보유 개발자 구인의 어려움, 핵심 멤버의 부재, 적절한 교육의 부재
- Requirements : 막대한 영향을 미치는 요구사항 변경, 그리고 그로 인해 주요 설계 재작업
- Technology : 트랜잭션처리 속도 느림, 재사용 컴포넌트에 포함된 오류
- Tools : 도구의 기능 부족, 개발문화에 맞지 않는 도구.
7. 좋은 소프트웨어 절차의 특징에 대해.
- 같은 소프트웨어 절차를 진행할 때, 이전 프로젝트에서 나온 결과를 통해 이번 프로젝트의 비용, 결함 등을 예측할 수 있다.
- 테스트와 유지보수가 쉽고, 비용을 줄일 수 있다.
- 계획하지 않았던 변화에도 잘 대응하고, 계속해서 계획을 확인할 수 있다.
- 앞 절차에서 오류를 찾고 고쳐 낮은 비용이 든다.
8. Waterfall Model에 대해 설명하세요.
- 다른 모델들의 기본이 되는 모델로, 개발에 착수하기 전에, 계획을 충분히 세우고 넘어갈 수 있게 한다. 
- 각 단계가 끝날 때 만들어야 하는 문서에 대해 명확히 정의되어 있어 관리가 쉽다.
- 문서를 작업하는 시간이 더 큰 프로젝트도 있으며, 개발 중 예측 불가한 변화에 유연한 대응이 어렵다.
9. development life cycle에 대해.
- 개발을 디자인하고 순서를 정한 모델들. 이론적으로는 이 모델을 따라가면 계획한 일정을 수행하며 품질을 보장할 수 있다.
10. RFP와 SOW의 차이점은?
- RFP는 고객에게 받는 제안 요청서이고, SOW는 해당 프로젝트에서 할 일과 목적과 제약사항을 포함한 작업 명세서이다.
11. 소프트웨어 비용 추정을 하는 이유 ( 잘 맞지도 않는 비용 계산을 굳이 하는 이유)
- 가이드라인이 있어야 개발 기간과 비용을 추정하고 계획을 세울 수 있다.
12. COCOMO2 모델의 3단계에 대해 설명하세요.
- 프로젝트 초기에 컴포넌트와 페이지 개수에 따라 사이즈를 결정하는 계획 단계
- 설계 단계 공식으로 각각의 기능에 따라 점수를 부여하는 단계
- 설계 이후에 프로그램의 코드라인 수(LOC) 예측
13. 애자일 모델과 다른 프로젝트 모델의 차이점
- 다른 모델이 문서에 초점을 두는 데에 반해, 애자일 모델은 프로그래밍에 초점을 맞추고, 고객과 자주 만나 피드백을 받는다.
14. RUP 모델이 기존의 워터폴 모델의 단점을 어떻게 없앴는지 서술
- RUP 모델은 모든 단계에서 water fall model의 한 주기를 실행함으로써, 변화에 유연하게 대응하도록 한다.
15. 프로젝트 모델을 고를 때 고려해야 할 것들
- 프로젝트 요구사항에 대해 얼마나 잘 이해하고 있는가.
- 프로젝트에 어떤 위험이 있을 수 있는가.
- 고객과 접촉이 많이 이루어질 수 있는가.
- 스케쥴은 어떻게 될 것인가.
- 프로젝트에 참여하는 사람들은 어느 수준을 가지고 있는가.

# 2주차

1. 요구사항 명세서에 작성할 기본 목차 및 요소들은 어떤게 있을지
- 개요 : 시스템의 목적과 범위, 정의와 약어, 참조가 기재된다.
- 사용자 요구사항: 사용자 인터페이스, 하드웨어 인터페이스, 소프트웨어 및 통신 인터페이스가 기재된다.
- 시스템 요구사항 : 기능적 요구사항과 비기능적 요구사항으로 나뉘어 기재하며, 사용 사례도 첨부한다.
- 기타 요구 및 제약 사항 : 성능, H/W, 예외 조건, 자원과 인력에 대한 제약이 들어간다.
- 인수 조건 : 기능과 성능에 대한 시험이 들어간다.
- 참고자료
2. use case diagram이란
- 사용자의 관점에서 시스템의 서비스와 기능, 외부 요소와 같은 상호작용을 표현한 것이다.
3. data flow diagram이란
- 만들고자 하는 요소를 함수로해서, 복잡한 시스템을 정제하고 분해하여 모델링 한 것. 데이터가 소프트웨어 내의 각 프로세스를 따라 흐르며 변환되는 모습을 나타낸 것이다.
4. 좋은 요구사항의 성질이란
- Unambiguos : 똑같은 요구사항에 대해, 누구나 언제나 똑같이 해석할 수 있다.
- Correct : 고객이 정말로 원한다.
- Consistent : 모든 요구사항은 일관성이 있어야 한다.
- Feasible : 소프트웨어로 구현 가능해야한다.
- Traceable : 요구사항이 객관적이라서, 어떻게 개발되고 테스팅되고 있는지 추적 가능하여, 객관적으로 검증할 수 있어야한다.
5. User requirements와 System requirements에 대해서
- User requirements는 사용자 입장에서 정리한 요구사항으로, 소프트웨어 기술 용어는 배제하고 작성된다.
- System requirements는 개발자 입장에서 정리된 요구사항으로, 기능적 요구사항과 비기능적 요구사항으로 나누어 깔끔하고 정밀하게 기술된다. 
6. 요구사항을 정리하는 것이 어려운 이유
- 소프트웨어를 요청하는 사람은, 자신의 분야를 다른 사람도 잘 안다고 생각하고 주문하는 경우가 많아, 의사소통에 차질이 생길 수 있다.
- 또한, 이해관계자가 여럿일 경우, 그들의 요구사항이 충돌할 경우에도 정리하기 어렵다.
7. Use Case에 대해 설명하세요.
- 사용자의 입장에서 바라본 시스템의 기능, 요구사항을 기술한 것이다.
8. Use Case 모델링 과정에서 관계를 구성하는 3가지 요소에 대해 설명하세요.
- System scope : 만들고자 하는 프로그램
- Actor : 시스템의 외부에서 시스템과 사용하는 사람이나 프로그램.
- Usecase : 시스템이 Actor에게 제공하는 기능.
9. SRS에 대해 설명하세요.
- 사용자 요구사항과 시스템 요구사항을 모두 포함된, 개발자가 필요로 하는 official statement이다.
10. 요구사항은 누구로부터 얻을 수 있는가?
- 고객, 해당 분야의 전문가, Skateholder, User, 이전에 만들어진 서비스, 제품으로부터 얻을 수 있다.
11. 요구사항 추출에서 나올 수 있는 문제
- 요구사항을 얻는 이들 간의 이해관계 때문에 추출하기 어려울 수 있다.
12. 요구사항에 우선순위를 매기는 이유
- 모든 요구사항을 적용하는 것은 어렵기 때문에, 우선순위를 매겨 개발한다.

# 3주차

1. 클라이언트-서버 아키텍처란
- 각자의 서비스를 제공하는 여러 서버들로 구성된 구조이다. 분산처리를 할 때 좋기 때문에 여러 지역에서 공유 데이터베이스를 사용할 때, 시스템 부하가 가변적이고 복제 서버를 둘 수 있을 때 사용한다.DOS 공격과 서버다운에 취약하다.
2. MVC 아키텍처란
- 데이터를 보여주는 부분과 처리하는 부분을 분리한 구조이다. Model, View, Controlle 패턴을 사용하는 서비스에서 사용한다. 여러 방법으로 똑같은 데이터를 보여주고 다룰 때, 데이터를 보이고 다루는 방법에 대한 요구사항이 명확하지 않을 때 사용한다.
3. Facade design이란 무엇인가
- 패키지 안의 클래스를 외부에서 사용하고자 할 때, Facade 모듈을 한 번 거치게 만든 디자인이다. 패키지안의 클래스가 변경되어도 외부 변경을 최소화 할 수 있다는 장점이 있다.
4. 클래스간의 포함관계와 합성관계의 차이는
- 서로 두 클래스가 있을 때, 포함관계는 포함되던 클래스가 없어지더라도 포함하던 클래스는 남아있다. 그러나 합성관계에서는 둘 중 한 클래스가 사라지면 다른 클래스도 같이 사라진다.
5. 클래스간의 연관관계와 의존관계의 차이는
- 둘 다 다른 클래스를 사용한다는 점에선 동일하지만, 연관관계는 클래스간의 관계가 오래 유지되고, 의존관계는 비교적 짧은 기간 동안만 유지된다.
6. Control Class에 대해
- 다른 분류인 Entity class의 내용을 만들고 업데이트하고, 동시에 Boundary class를 제어하는 클래스이다.
7. Event-driven Control의 장단점은
- 장점 : 함수 모듈끼리 직접적으로 연결된 것이 아니기 때문에, 시스템 변경이 상대적으로 쉽다.
- 단점 : 브로드캐스트 모델의 컴포넌트에서, 이벤트가 언제 처리될지, 또한 처리 될지 여부를 모른다.
8. Repository Architecture란
- 시스템의 모든 데이터를 중앙저장소에서 관리하는 구조이다. 컴포넌트끼리 직접 데이터를 교환하지 않으며, 큰 용량의 데이터를 만들어 오래 저장하는 유형의 시스템을 만들 때 적합하다.
9. Pipe and Filter Architecture의 특징은
- 각 데이터 처리 컴포넌트가 명확히 구분되어 있어 한 가지 유형의 데이터 변환을 담당한다는 특징이 있다. 한 컴포넌트가 출력한 데이터를 다른 컴포넌트가 입력으로 사용한다. 변환 필터 재사용과 추가가 용이하며 비즈니스 처리 구조에 적합하다는 장점이 있으나, 서로 인접한 변환끼리의 데이터 형식을 미리 정해야한다는 번거로움이 있다.
10. 아키텍처 설계에 대해 설명하세요.
- 사용자가 원하는 기능들을 연결시켜 관계를 표현하는 이른바 설계도를 만드는 것이다. 이 기능 사이 빠진 부분은 직접 채워넣어야하므로 창의력을 요한다.
11. Splitting our reads and write 아키텍처의 특징은?
- 한 가지 기능만 하도록 모듈을 분리한 것으로, 사람들이 많이 사용하는 기능에 집중하여 성능을 높일 수 있다.
12. 보안성을 늘리기 위해 사용하는 아키텍처가 무엇인지 설명하세요
- Layered Architecture를 사용한다. 상하로 인접한 모듈끼리만 호출할 수 있으므로, 가장 안쪽에 가장 보안이 중요한 자산을 넣어 보안성을 높일 수 있다.
13. Activity Diagram의 특징
- 객체의 상태가 아닌 처리 로직이나 조건에 따른 흐름을 순서에 따라 정의한 것으로, 비즈니스 프로세스를 정의하는 것에 적합하다.
14. Sequence Diagram의 특징
- 특정 기능이 어떤 순서로 어떤 객체와 어떻게 상호작용하는지를 표현한다. sequencing, interaction, selection으로 표현할 수 있다.
15. State Diagram의 특징
- 하나의 객체를 대상으로 라이프타임동안 가질 수 있는 객체 상태 변화를 분석한 것이다. 상태 변화를 유발하는 이벤트와 동작도 함께 정의하며,  event, condition, action 세 개로 표현할 수 있다.

# 4주차

1. 개방폐쇄 원리에대해서 설명하세요
- 모든 모듈은 확장 가능해야 한다는 원리로, 처음부터 개발할 때에 다른 기능을 쉽게 추가할 수 있게 만들어야 한다는 것이다.
2. 리스코프 치환 원리에대해서 설명하세요
- 프로그램에 있는 부모 객체들은 자식 객체들로 대체가능해야하며, 부모클래스의 행동규약을 자식 객체가 위반해서는 안된다는 원리다.
3. 의존 역전 원리에대해서 설명하세요
- 추상화된 모듈에 의존하라는 원리로, 상위 모듈과의 종속성을 줄여 유지관리와 수정이 용이한 코드를 작성하라는 것이다.
4. Design Pattern을 세 타입으로 어떻게 분류할 수있는지.
- Creational Pattern type : 객체 생성과 관련된 패턴
- Structural pattern type : 객체의 구성, 구조를 잡는 것과 관련된 패턴
- Behaviral pattern type : 객체를 생성하여 서로 호출 할 때 각자의 객체가 하는 일을 배치하는 것과 관련된 패턴
5. Factory Method Pattern에 대해
- 객체 생성 시에 정확한 클래스 이름을 지정하지 않고 생성하는 것으로 Creational pattern에 속한다. 클래스와 객체간의 의존성이 생기는 것을 방지하기 위해 사용한다.
6. Abstract Factory Pattern은 어떤 상황에서 권장되는가
- 구체적인 클래스에 의존하지 않고 연관관계가 있는 객체를 여러 개 생성하고자 할 때 권장된다.
7. 단계적 분해가 무엇인지 설명하세요.
- 복잡한 모듈을 작성할 때, 가장 대표적인 단계를 찾은 다음, 또 그 각 단계의 세부 단계를 감당할 수 있는 만큼 찾아 설계하는 것이다. 
8. 추상화의 종류 3가지에 대해 설명하세요.
- 과정 추상화 : 프로그래밍을 하기 전에 상세 부분은 생략하고 전체 흐름만 파악하도록 알고리즘 형태로 작성한다.
- 데이터 추상화 : 데이터를 모아 구조형태로 포현하는데, 사용자에게 클래스가 제공할 수 있는 사용법만 알리고 불필요한 데이터는 감춘다.
- 제어 추상화 : 여러 줄을 간략히 줄여, 프로그래밍 언어에서 쓰는 제어구조를 추상화 한다.
9. 결합도, 응집도에 대해 설명하세요.
- 결합도란 한 모듈이 다른 모듈에게 얼마나 의존하는가를 나타낸다. 결합도가 높아지면 독립성이 떨어지므로, 결합도를 낮추어야한다.
- 응집도란 하나의 모듈을 구성하는 문장들이 일관되는가를 나타낸다. 한 모듈은 한 기능만을 구현해야하는데, 다른 것이 포함된다면 응집도가 낮은 것이다. 따라서 응집도는 높여야한다.
10. 단일 객체 패턴에 대해 설명하세요.
- 프로그램이 실행되는 동안에 객체의 수가 항상 하나가 되는 것을 보장하여 만드는 패턴으로, 메모리 낭비를 방지할 수 있다. 최초 생성 이후에 호출된 생성자들은 이미 생성한 객체를 반환한다.
11. 어댑터 패턴에 대해 설명하세요.
- 서로 호환되지 않는 인터페이스끼리 연결할 때, 어댑터라는 새로운 클래스를 만들어 사용하는 패턴이다. 클라이언트 코드를 한 줄도 바꾸지 않고 레거시 코드를 변경할 수 있다는 것이 장점이다.
12. 컴포짓 패턴에 대해 설명하세요.
- 여러개의 공통된 인터페이스를 가진 객체를 하나의 객체처럼 다루고 싶을 때 쓸 수 있는 패턴으로, 새로운 객체를 포함시키거나 변경할 때 기존의 패턴을 바꾸지 않을 수있다.